import { exec } from 'node:child_process';
import fs from 'node:fs';
import process from 'node:process';

import { parseBabel } from '../codeshift/utils/babel.mjs';
import { getFilesByType } from '../codeshift/utils/files.mjs';
import { getConfig } from '../codeshift/utils/get-config.mjs';

function camelize(str, { firstUpper } = {}) {
  return str
    .split(/-(?![0-9])/)
    .map((part, idx) => {
      // String started with a dash
      if (part === '') {
        return '-';
      }
      if (idx > 0 || firstUpper) {
        return part[0].toUpperCase() + part.slice(1).toLowerCase();
      }
      return part.toLowerCase();
    })
    .join('');
}

const TYPES = {
  service: {
    fileType: 'service',
    entryKeys(name) {
      const dasherized = name;
      const parts = name.split('/');
      const camelized = parts.map(camelize).join('/');
      const ret = [dasherized];
      if (camelized !== dasherized) {
        ret.push(camelized);
      }
      return ret;
    },
    fallbackImport: '@ember/service',
  },
};

const TYPE_KEYS = Object.keys(TYPES);

export async function generateTypes() {
  const CONFIG = getConfig();

  if (CONFIG.debug) {
    console.log(CONFIG);
  }

  if (!CONFIG.project) {
    throw new Error('Project path is required');
  }

  const gitStage = process.argv.includes('--git-stage');

  const typeArg = process.argv.find((arg) => arg.startsWith('--type='));
  const types = typeArg ? typeArg.substring(7).split(',') : TYPE_KEYS;
  if (types.some((type) => !TYPE_KEYS.includes(type))) {
    throw new Error(`Invalid type. Must be one of ${TYPE_KEYS.join(', ')}`);
  }

  for (const typeKey of types) {
    const typeConfig = TYPES[typeKey];
    const fileTypes = Array.isArray(typeConfig.fileType) ? typeConfig.fileType : [typeConfig.fileType];
    const files = (await Promise.all(fileTypes.map((t) => getFilesByType(t)))).flat();
    console.log(`Processing ${files.length} ${typeKey} files in ${CONFIG.project}`);

    const imports = new Set();
    const entries = {};

    for (const file of files) {
      if (file.endsWith('/registry.d.ts')) {
        continue;
      }

      if (!file.endsWith('.d.ts') && fs.existsSync(file.replace(/\.[^/.]+$/, '.d.ts'))) {
        // We'll process the adjacent .d.ts instead
        continue;
      }

      const importPath = file
        .replace(`${CONFIG.project}/${CONFIG.sourceDir}`, CONFIG.modulePrefix)
        .replace(/\..+$/, '');
      const importParts = importPath.split('/').slice(2);

      let className;

      // Special case for template-only
      if (file.endsWith('.hbs')) {
        className = `GlimmerComponent`;
        imports.add(`import type GlimmerComponent from '@glimmer/component';`);
      } else {
        const srcCode = fs.readFileSync(file, { encoding: 'utf-8' });
        if (!srcCode.includes('export default')) {
          continue;
        }

        let isClassicClass;
        if (file.endsWith('.js') && !fs.existsSync(file.replace(/\.js$/, '.d.ts'))) {
          try {
            const parsed = parseBabel(srcCode);

            const defaultExport = parsed?.program.body.find((node) => node.type === 'ExportDefaultDeclaration');

            isClassicClass =
              defaultExport?.declaration.type === 'CallExpression' &&
              defaultExport.declaration.callee.property?.name === 'extend';
          } catch (e) {
            console.error(`\n\nError parsing ${file}`);
            throw e;
          }
        }

        if (isClassicClass && typeConfig.fallbackImport) {
          className = `Fallback${typeKey[0].toUpperCase() + typeKey.slice(1)}`;
          imports.add(`import type ${className} from '${typeConfig.fallbackImport}';`);
        } else {
          className = importParts
            .map((p) => camelize(p, { firstUpper: true }))
            .join('')
            .replace('-', '');

          if (importPath === typeConfig.fallbackImport) {
            className = `Fallback${typeKey[0].toUpperCase() + typeKey.slice(1)}`;
          }

          imports.add(`import type ${className} from '${importPath}';`);
        }
      }

      const itemEntries = typeConfig
        .entryKeys(importParts.join('/'))
        .map((entryKey) =>
          typeConfig.keysOnly
            ? `'${entryKey}'`
            : `	'${entryKey}': ${typeConfig.needsTypeof ? 'typeof ' : ''}${className};`,
        );
      entries[importPath] = itemEntries;
    }

    const typeName = typeKey[0].toUpperCase() + typeKey.slice(1);

    const output = [];
    output.push('/* ================================================================== *');
    output.push(' *                 This file is auto-generated                        *');
    output.push(' * This file is generated by running `pnpm generate:type-registries`. *');
    output.push(' * ================================================================== */');
    output.push('');

    if (typeConfig.keysOnly) {
      output.push('');
      output.push(`export type Project${typeName}Name =`);
      output.push(
        ...Object.entries(entries)
          .sort(([aName], [bName]) => aName.localeCompare(bName))
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          .flatMap(([_, e]) => `	| ${e}`),
      );
      output[output.length - 1] = `${output[output.length - 1]};`;
    } else {
      output.push(...[...imports].sort());
      output.push('');
      output.push(`export default interface Project${typeName}Registry {`);
      output.push(
        ...Object.entries(entries)
          .sort(([aName], [bName]) => aName.localeCompare(bName))
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          .flatMap(([_, e]) => e),
      );
      output.push('}');
    }

    output.push('');

    if (CONFIG.dryRun) {
      console.log(output.join('\n'));
    } else {
      const filePath = `${CONFIG.project}/${CONFIG.sourceDir}/${typeKey}s/registry.d.ts`;
      fs.writeFileSync(filePath, output.join('\n'));

      if (gitStage) {
        await exec(`git add ${filePath}`);
      }
    }

    console.log(`Added ${Object.keys(entries).length} ${typeKey} entries`);
  }
}
